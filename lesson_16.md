# Вариант 1

## Обычные индексы
<br>
<br>
><u>Используем демо базу ***bokking*** бронирования белетов</u>

><u>Используем таблицу ***flights***</u>

><u>Оптимизатор предполагает, что в таблице ***flights*** по данному условию размещено 18447 строк. ОРткуда он знает?</u>

![](lesson_16-8.jpg)

<u> Данный критерий поиска является наиболее характерным для данного столбца данной таблицы</u>

![](lesson_16-9.jpg)

<u>Умножив 0.28093332 (частоту встречаемости) на 65664 (количество строк в таблице) получим 18 447. И как можно заметить оптимизатор сильно не ошибся</u>

![](lesson_16-10.jpg)

<u>Но поскольку на столбце нет индекса оптимизатор будеи сканировать таблицу и применять к ней фильтр/u>

![](lesson_16-8.jpg)

<u>Построим индекс (***create index flights_aircraft_code on bookings.flights(aircraft_code)***) и выполним запрос еще раз</u>
><u>На шаге 1 использхованием индекса были выбраны страницы, на которых размещены искомые данные</u>

><u>На шаге 2 построена битовая маска где каждый бит соответсвует странице с данными</u>

><u>На шаге 3 выбраны интересующие нас строки и возвращены клиенту.</u>

![](lesson_16-11.jpg)

## Полнотекстовые индексы

><u>Создадим тестовую базу для полнотекстового поиска и насыпим туда данных.</u>

![](lesson_16-12.jpg)

><u>Убедимся, что поис работает хотя пока без индекса.</u>

![](lesson_16-13.jpg)

><u>Добавим столбец в таблицу и построим индекс.</u>

![](lesson_16-14.jpg)

><u>Добавим данные в созданный столбец.</u>

![](lesson_16-15.jpg)

><u>Обратите вниманиеЮ что поиск происходит по словоформам. Мы искали ***break***, а найдено ***breaking*** </u>

![](lesson_16-16.jpg)

><u>Более сложный поиск </u>

![](lesson_16-17.jpg)

## Индекс на части данных.

><u>Предположим, что мы работаем в аэропорту города Усинск и нас интересуют только данные по вылетам из этого аэропорта. Создаем индекс.</u>

![](lesson_16-18.jpg)

><u>Как видим индекс используется.</u>

![](lesson_16-19.jpg)

><u>Создадим индекс по двум столбцам</u>

![](lesson_16-20.jpg)

><u>Здесь классика жанра. Поиск по дереву индекса->составление битмапов страниц->выборка строк из битмапленных страниц.</u>

![](lesson_16-21.jpg)

><u>Изменим результирующий набор. И этап битмапов исчез. В данном случае мы имеем Индекс покрывающий запрос и все данные есть в дереве индекса, а поэтому обращение к старницам данных не нужно.</u>

![](lesson_16-22.jpg)


# Вариант 2

***Написания запросов с различными типами соединений***
<br>
<br>
><u>Создадим тестовую базу, а также объекты в ней, и насыпим туда немного данных</u>

![](lesson_16-1.jpg)

## Реализовать прямое соединение двух или более таблиц

><u>В результат входят только строки соответствующие равенству в операторе ***ON***</u>

![](lesson_16-2.jpg)



## Реализовать левостороннее (или правостороннее) соединение двух или более таблиц
<u>Студентка Lucy не здавала ни одно экзамена, поэтому на месте экзаменов ***NULL***</u>

![](lesson_16-3.jpg)

<u>А был студент, под ***ID=5*** который сдавал экзамен, а потом его выгнали (шутка), поэтому на месте данных о студенте из таблицы ***students*** стоит ***NULL***</u>

![](lesson_16-4.jpg)

# Реализовать полное соединение двух или более таблиц

<u>А тут все. Тут и Lucy, которая сачконула экзамен, и студент, которого выперли из вуза.</u>

![](lesson_16-5.jpg)

# Реализовать кросс соединение двух или более таблиц

<u>А тут все варианты студентов и экзаменов. Это Декартово (безусловное) произведение двух множеств.</u>

![](lesson_16-6.jpg)

# Самосоединение двух или более таблиц

<u>Найти имена студентов сдававших одинаковые экзамены.</u>

![](lesson_16-7.jpg)



><u>ДЗ завершил. Ура.</u>